<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script type="text/javascript">
    //console.log中如果同时输出多个值,每个值之间用逗号隔开
    //use strict 使用严格模式
    //使用call和apply方法来改  变我们的this-->让当前的函数执行,把里面的this关键字进行改变
    //call和apply:
    //1.首先都是让当前操作的这个函数执行,然后把函数中的this改变为我们第一个参数传递的值
    //[function].call([this],parameter1,parameter2,parameter3...)
    // [function].call([this],[parameter1,parameter2,parameter3...])
    //2.区别只在于传递参数的时候call是把传递的参数值一个个传进去,apply是把要传的参数值放到一个数组中,然后一起传进去,但是只是写法不同,效果还是给形参依次赋值;如果执行的时候一个参数都没有写,默认this是window,例如:fn.call() fn中的this-->window.
    //在非严格模式下,我们第一个参数写null或者undefined,this都是window
    //在严格模式下,你写啥就是啥,不写就是undefined;
    //call和apply是定义在function这个基类的原型上的,而所有的函数都是function这个类的一个实例,所以所有的函数都可以使用我们的call和apply方法
    //函数:所有的内置类都是函数,所有的function都是函数
    //为啥函数可以调用call这个方法
      //Function js中所有函数数据类型对应的基类,call和apply就是定义在Function这个基类的原型上的,而没一个函数都是Function这个基类的一个实例,所以所有的函数都可以使用call和apply方法
   /*  var ary=[4,2,3,34,45,2,123,4345,12,21,234,145,121414];
     var max=Math.max.apply(null,ary);
     var min=Math.min.apply(null,ary);
     console.log(max,min);*/
    //call和apply的应用
    //求最大值和最小值
    //1.数组方法先排序,然后掐头去尾
    //2.假设法:假设第一个是最大的(最小的),然后让第一个和后面的一个个比较,如果后面的比第一个       还要打(还要小),说明我们假设的是错误的,然后让当前的项变为我们新的假设
    //3.借用Math中max/min实现最大值和最小值的获取;利用apply在传递参数的时候是将参数放到        一个数组中一起传进去的原理实现的
    //求平均分
    //先排序,去除第一个和最后一个，剩下的累加然后除以长度
    //arguments里面存储了我们传进来的参数,它是一个类数组,所以不能直接的使用我们的数组方法,如果想使用这些方法,我们首先把他转化为数组:
    /* var ary=[];
     for(var i=0;i<arguments.length;i++){
     ary[i]=arguments[i];
     }*/
    //    var ary=Array.prototype.slice.call(arguments,0);
    //      var ary=[].slice.call(arguments,0)
    //删除最后一个  ary.length=ary.length-1;
    //删除第一个 ary[0]=ary[ary.length-1]; ary.length=ary.length-1;
    //求平均数
    // var str=ary.join("+");console.log(eval(str))/ary.length;
    //HTMLCollection(标签集合)类数组集合
    //NodeList(节点集合)类数组集合
    //我们如果用Array.prototype.slice.call的思想来操作我们的DOM集合(HTMLCollection,NodeList)的类数组,将其转化为数组,在IE6~8下不兼容(arguments是没有兼容问题的)

    //try.catch捕获异常信息,并且不影响下面代码执行
   /* try{
        //我们执行的代码
    }
    catch (e)
        //如果js代码执行的时候报错了,这里可以获取报错信息
        //e就是我们的存储错误信息的对象
        //e.code  错误码
        //e.message 报错信息
        //如果进入catch,说明try中的代码报错了
    }
    finally{
        //通常不加:不管try中的代码是否报错,finally中的代码都会执行
    }*/

    //在js中,不做任何处理的情况下,当前代码报错,下面的所有代码都不执行了;而用try.catch捕获异常后,下面的代码也可以正常执行
    //在js中我们可以手动抛出异常错误
    //throw new Error("报错信息")
    //我们通常也用try.catch检测js兼容问题:如果不兼容的一个方法执行会报错,我们可以监听是否报错报错的话就是
    var ary=[
        {name:"钱",age:25},
        {name:"孙",age:20},
        {name:"李",age:19},
        {name:"周",age:26},
        {name:"吴",age:34},
        {name:"郑",age:22}
    ];
    ary.sort(function(a,b){
        return parseInt(b.age)-parseInt(a.age);
    });
    console.log(ary);
</script>
</body>
</html>